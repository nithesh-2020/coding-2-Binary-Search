# -*- coding: utf-8 -*-
"""Binary_Search2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Vk_mlRwAMW1DcnGuOUxQHHQA2gqKIM5I
"""

#find peak element

#time complexity O(log(n))

class Solution(object):
    def findPeakElement(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        left, right = 0, len(nums) - 1

        while left < right:
            mid = left + (right - left) / 2
            if nums[mid] > nums[mid + 1]:
                right = mid
            else:
                left = mid + 1

        return left

#find min of sorted array

#time complexity O(log(n))

class Solution(object):
    def findMin(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        min1 = nums[0]
        l, r = 0, len(nums)-1
        while l<=r:
            if nums[l]<nums[r]:
                min1 = min(min1,nums[l])
                break
            m = (l+r)//2
            min1 = min(min1,nums[m])
            
            if(nums[m]>=nums[l]):
                l=m+1
            else:
                r=m-1
        return min1

#34. Find First and Last Position of Element in Sorted Array

#time complexity O(log(n))

class Solution(object):
    def searchRange(self, arr, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: List[int]
        """
        firstPos = self.StartPos(arr, target, 0, len(arr) - 1)

        lastPos = self.EndPos(arr, target, 0, len(arr) - 1)

        return [firstPos, lastPos]
    
    def StartPos(self, arr, target, low, high):

        while(low<=high):

            mid = low + (high - low)//2

            if arr[mid] == target:

                if low == mid or arr[mid - 1] < arr[mid]:

                    return mid

                else:

                    high = mid - 1

            elif arr[mid] > target:

                high = mid - 1

            else:

                low = mid + 1

        return -1
    
    def EndPos(self, arr, target, low, high):

        while(low<=high):

            mid = low + (high - low)//2

            if arr[mid] == target:

                if high == mid or arr[mid + 1] > arr[mid]:

                    return mid

                else:

                    low = mid + 1

            elif arr[mid] > target:

                high = mid - 1

            else:

                low = mid + 1